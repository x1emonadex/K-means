#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <cmath>
#include <random>
#include <algorithm>
#include <limits>
#include <iomanip>
#include <chrono>

#pragma comment(lib, "comctl32.lib")

#ifdef max
#undef max
#endif
#ifdef min
#undef min
#endif

#define ID_LOAD_BUTTON 1001
#define ID_CALC_BUTTON 1002
#define ID_K_INPUT 1003
#define ID_THRESHOLD_INPUT 1004
#define ID_MAX_ITER_INPUT 1005
#define ID_EXPORT_BUTTON 1007
#define ID_CLEAR_BUTTON 1008
#define ID_RESULTS_LIST 1009
#define ID_CLUSTERS_LIST 1010
#define ID_POINTS_LIST 1011
#define ID_STATS_LIST 1012

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
HINSTANCE hInst;
WCHAR szTitle[] = L"–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ K-means - –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è";
WCHAR szWindowClass[] = L"KmeansAnalyzerClass";
OPENFILENAME ofn;
wchar_t szFile[MAX_PATH] = L"";
wchar_t szSaveFile[MAX_PATH] = L"";

// –®—Ä–∏—Ñ—Ç—ã - –î–û–ë–ê–í–õ–ï–ù hFontRange
HFONT hFontTitle, hFontButton, hFontText, hFontBold, hFontRange;

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
struct Point {
    std::vector<double> coords;
    int clusterLabel = -1;
    int originalIndex = 0;
};

struct ClusterInfo {
    std::vector<double> centroid;
    int pointCount = 0;
    double avgDistance = 0.0;
    double minDistance = std::numeric_limits<double>::max();
    double maxDistance = 0.0;
    double variance = 0.0;
    double compactness = 0.0;
};

// –î–∞–Ω–Ω—ã–µ
std::vector<Point> points;
std::vector<ClusterInfo> clusters;
int k = 3;
int maxIterations = 100;
double convergenceThreshold = 0.01;
int currentIteration = 0;
bool isConverged = false;
double totalSSE = 0.0;
std::mt19937 rng(std::random_device{}());
std::chrono::steady_clock::time_point startTime;

// UI —ç–ª–µ–º–µ–Ω—Ç—ã - –î–û–ë–ê–í–õ–ï–ù–´ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
HWND hLoadBtn, hCalcBtn, hExportBtn, hClearBtn;
HWND hKInput, hThresholdInput, hMaxIterInput;
HWND hResultsList, hClustersList, hPointsList, hStatsList;
HWND hStatusText, hProgressBar;
HWND hTabControl;
HWND hKRangeLabel, hThresholdRange, hIterRange;

// –§—É–Ω–∫—Ü–∏–∏
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void InitializeResources();
void CleanupResources();
void CreateInterface(HWND hWnd);
void ResizeInterface(HWND hWnd, int width, int height);
HWND CreateListView(HWND parent, int x, int y, int w, int h, int id);
void AddListColumn(HWND hList, LPCWSTR text, int width, int index);
void AddListItem(HWND hList, int item, int subitem, LPCWSTR text);
void ClearList(HWND hList);
void CreateTabControl(HWND hWnd);
void ShowTabContent(int tabIndex);
void UpdateKRangeLabel();
void AutoResizeColumns(HWND hListView); // –î–û–ë–ê–í–õ–ï–ù–ê –Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è

// –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
void ShowWelcomeScreen();
void ShowDataLoadedInfo();
void ShowClusteringResults();
void UpdateStatus(const std::wstring& message);
void PopulateResultsTable();
void PopulateClustersTable();
void PopulatePointsTable();
void PopulateStatsTable();

// K-means –∞–ª–≥–æ—Ä–∏—Ç–º
void LoadDataFile();
void RunClusteringAnalysis();
void InitializeCentroidsKMeansPlusPlus();
double CalculateEuclideanDistance(const std::vector<double>& a, const std::vector<double>& b);
void AssignPointsToClusters();
void UpdateClusterCentroids();
void CalculateDetailedStatistics();
bool ExportDetailedResults();
void ClearAllData();

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR, int nCmdShow)
{
    hInst = hInstance;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Common Controls
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES;
    InitCommonControlsEx(&icex);

    WNDCLASSEXW wcex = { sizeof(WNDCLASSEX) };
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.hInstance = hInst;
    wcex.hIcon = LoadIcon(nullptr, IDI_APPLICATION);
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszClassName = szWindowClass;

    RegisterClassExW(&wcex);

    HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, 1600, 1000, nullptr, nullptr, hInst, nullptr);

    if (!hWnd) return FALSE;

    InitializeResources();
    CreateInterface(hWnd);
    ShowWelcomeScreen();

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    MSG msg;
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    CleanupResources();
    return (int)msg.wParam;
}

void InitializeResources()
{
    hFontTitle = CreateFontW(24, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Segoe UI");

    hFontButton = CreateFontW(14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Segoe UI");

    hFontText = CreateFontW(13, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Segoe UI");

    hFontBold = CreateFontW(14, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Segoe UI");

    // –î–û–ë–ê–í–õ–ï–ù –Ω–æ–≤—ã–π —à—Ä–∏—Ñ—Ç –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ - –∂–∏—Ä–Ω—ã–π –∏ —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π
    hFontRange = CreateFontW(14, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Segoe UI");
}

void CleanupResources()
{
    DeleteObject(hFontTitle);
    DeleteObject(hFontButton);
    DeleteObject(hFontText);
    DeleteObject(hFontBold);
    DeleteObject(hFontRange); // –î–û–ë–ê–í–õ–ï–ù–û —É–¥–∞–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —à—Ä–∏—Ñ—Ç–∞
}

void CreateInterface(HWND hWnd)
{
    // –ó–∞–≥–æ–ª–æ–≤–æ–∫
    CreateWindowW(L"STATIC", L"üî¨ –ü–†–û–§–ï–°–°–ò–û–ù–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó–ê–¢–û–† –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–ò K-MEANS",
        WS_VISIBLE | WS_CHILD | SS_CENTER,
        20, 20, 1540, 40, hWnd, nullptr, hInst, nullptr);

    // === –õ–ï–í–ê–Ø –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø ===

    // –ì—Ä—É–ø–ø–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    CreateWindowW(L"BUTTON", L"1. –ó–ê–ì–†–£–ó–ö–ê –î–ê–ù–ù–´–•",
        WS_VISIBLE | WS_CHILD | BS_GROUPBOX,
        20, 80, 400, 100, hWnd, nullptr, hInst, nullptr);

    hLoadBtn = CreateWindowW(L"BUTTON", L"üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å CSV —Ñ–∞–π–ª",
        WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
        40, 110, 180, 35, hWnd, (HMENU)ID_LOAD_BUTTON, hInst, nullptr);

    hClearBtn = CreateWindowW(L"BUTTON", L"üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ",
        WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
        240, 110, 160, 35, hWnd, (HMENU)ID_CLEAR_BUTTON, hInst, nullptr);

    // –ì—Ä—É–ø–ø–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    CreateWindowW(L"BUTTON", L"2. –ü–ê–†–ê–ú–ï–¢–†–´ –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–ò",
        WS_VISIBLE | WS_CHILD | BS_GROUPBOX,
        20, 200, 400, 160, hWnd, nullptr, hInst, nullptr);

    CreateWindowW(L"STATIC", L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ (k):",
        WS_VISIBLE | WS_CHILD,
        40, 230, 180, 20, hWnd, nullptr, hInst, nullptr);
    hKInput = CreateWindowW(L"EDIT", L"3",
        WS_VISIBLE | WS_CHILD | WS_BORDER | ES_NUMBER,
        230, 228, 60, 25, hWnd, (HMENU)ID_K_INPUT, hInst, nullptr);

    hKRangeLabel = CreateWindowW(L"STATIC", L"(2-8)",
        WS_VISIBLE | WS_CHILD,
        300, 230, 80, 20, hWnd, nullptr, hInst, nullptr);

    CreateWindowW(L"STATIC", L"–ü–æ—Ä–æ–≥ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏:",
        WS_VISIBLE | WS_CHILD,
        40, 260, 150, 20, hWnd, nullptr, hInst, nullptr);
    hThresholdInput = CreateWindowW(L"EDIT", L"0.01",
        WS_VISIBLE | WS_CHILD | WS_BORDER,
        200, 258, 80, 25, hWnd, (HMENU)ID_THRESHOLD_INPUT, hInst, nullptr);

    // –î–û–ë–ê–í–õ–ï–ù–û —Å–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –ø–æ—Ä–æ–≥–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    hThresholdRange = CreateWindowW(L"STATIC", L"(0.001-0.1)",
        WS_VISIBLE | WS_CHILD,
        290, 260, 80, 20, hWnd, nullptr, hInst, nullptr);

    CreateWindowW(L"STATIC", L"–ú–∞–∫—Å–∏–º—É–º –∏—Ç–µ—Ä–∞—Ü–∏–π:",
        WS_VISIBLE | WS_CHILD,
        40, 290, 150, 20, hWnd, nullptr, hInst, nullptr);
    hMaxIterInput = CreateWindowW(L"EDIT", L"100",
        WS_VISIBLE | WS_CHILD | WS_BORDER | ES_NUMBER,
        200, 288, 80, 25, hWnd, (HMENU)ID_MAX_ITER_INPUT, hInst, nullptr);

    // –î–û–ë–ê–í–õ–ï–ù–û —Å–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏–π
    hIterRange = CreateWindowW(L"STATIC", L"(5-500)",
        WS_VISIBLE | WS_CHILD,
        290, 290, 80, 20, hWnd, nullptr, hInst, nullptr);

    // –ì—Ä—É–ø–ø–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    CreateWindowW(L"BUTTON", L"3. –í–´–ü–û–õ–ù–ï–ù–ò–ï –ê–ù–ê–õ–ò–ó–ê",
        WS_VISIBLE | WS_CHILD | BS_GROUPBOX,
        20, 380, 400, 120, hWnd, nullptr, hInst, nullptr);

    hCalcBtn = CreateWindowW(L"BUTTON", L"üöÄ –ó–ê–ü–£–°–¢–ò–¢–¨ –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–Æ",
        WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
        40, 410, 360, 45, hWnd, (HMENU)ID_CALC_BUTTON, hInst, nullptr);

    // –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
    hProgressBar = CreateWindowW(PROGRESS_CLASS, nullptr,
        WS_VISIBLE | WS_CHILD | PBS_SMOOTH,
        40, 465, 360, 20, hWnd, nullptr, hInst, nullptr);

    // –ì—Ä—É–ø–ø–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞
    CreateWindowW(L"BUTTON", L"4. –≠–ö–°–ü–û–†–¢ –†–ï–ó–£–õ–¨–¢–ê–¢–û–í",
        WS_VISIBLE | WS_CHILD | BS_GROUPBOX,
        20, 520, 400, 80, hWnd, nullptr, hInst, nullptr);

    hExportBtn = CreateWindowW(L"BUTTON", L"üíæ –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞",
        WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
        40, 550, 360, 35, hWnd, (HMENU)ID_EXPORT_BUTTON, hInst, nullptr);

    // === –ü–†–ê–í–ê–Ø –ü–ê–ù–ï–õ–¨ –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ===

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    CreateWindowW(L"STATIC", L"üìä –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ê–ù–ê–õ–ò–ó–ê",
        WS_VISIBLE | WS_CHILD | SS_CENTER,
        450, 80, 1100, 30, hWnd, nullptr, hInst, nullptr);

    // –°—Ç–∞—Ç—É—Å
    CreateWindowW(L"STATIC", L"–°—Ç–∞—Ç—É—Å:",
        WS_VISIBLE | WS_CHILD,
        450, 120, 60, 20, hWnd, nullptr, hInst, nullptr);
    hStatusText = CreateWindowW(L"EDIT", L"",
        WS_VISIBLE | WS_CHILD | WS_BORDER | ES_MULTILINE | ES_READONLY | WS_VSCROLL,
        520, 120, 1030, 60, hWnd, nullptr, hInst, nullptr);

    // –°–æ–∑–¥–∞–µ–º –≤–∫–ª–∞–¥–∫–∏
    CreateTabControl(hWnd);

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —à—Ä–∏—Ñ—Ç—ã
    SendMessage(hLoadBtn, WM_SETFONT, (WPARAM)hFontButton, TRUE);
    SendMessage(hClearBtn, WM_SETFONT, (WPARAM)hFontButton, TRUE);
    SendMessage(hCalcBtn, WM_SETFONT, (WPARAM)hFontButton, TRUE);
    SendMessage(hExportBtn, WM_SETFONT, (WPARAM)hFontButton, TRUE);
    SendMessage(hKInput, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hThresholdInput, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hMaxIterInput, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hStatusText, WM_SETFONT, (WPARAM)hFontText, TRUE);

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–π –∂–∏—Ä–Ω—ã–π —à—Ä–∏—Ñ—Ç –∫–æ –≤—Å–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º
    SendMessage(hKRangeLabel, WM_SETFONT, (WPARAM)hFontRange, TRUE);
    SendMessage(hThresholdRange, WM_SETFONT, (WPARAM)hFontRange, TRUE);
    SendMessage(hIterRange, WM_SETFONT, (WPARAM)hFontRange, TRUE);
}

void UpdateKRangeLabel()
{
    if (points.empty()) {
        SetWindowTextW(hKRangeLabel, L"(min - 2)");
    }
    else {
        std::wstring rangeText = L"(2-" + std::to_wstring(points.size()) + L")";
        SetWindowTextW(hKRangeLabel, rangeText.c_str());
    }
}

// –ò–°–ü–†–ê–í–õ–ï–ù–ê —Ñ—É–Ω–∫—Ü–∏—è CreateTabControl —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ —Ä–∞–∑–º–µ—Ä–∞–º–∏ —Å—Ç–æ–ª–±—Ü–æ–≤
void CreateTabControl(HWND hWnd)
{
    // –°–æ–∑–¥–∞–µ–º Tab Control
    hTabControl = CreateWindowW(WC_TABCONTROL, L"",
        WS_VISIBLE | WS_CHILD | TCS_TABS,
        450, 200, 1100, 750, hWnd, nullptr, hInst, nullptr);

    if (!hTabControl) {
        MessageBoxW(hWnd, L"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∫–ª–∞–¥–æ–∫", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
        return;
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –≤–∫–ª–∞–¥–∫–∏
    TCITEM tie;
    tie.mask = TCIF_TEXT;

    tie.pszText = (LPWSTR)L"üìã –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è";
    TabCtrl_InsertItem(hTabControl, 0, &tie);

    tie.pszText = (LPWSTR)L"üéØ –ö–ª–∞—Å—Ç–µ—Ä—ã";
    TabCtrl_InsertItem(hTabControl, 1, &tie);

    tie.pszText = (LPWSTR)L"üìç –¢–æ—á–∫–∏ –¥–∞–Ω–Ω—ã—Ö";
    TabCtrl_InsertItem(hTabControl, 2, &tie);

    tie.pszText = (LPWSTR)L"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞";
    TabCtrl_InsertItem(hTabControl, 3, &tie);

    // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –∫–∞–∂–¥–æ–π –≤–∫–ª–∞–¥–∫–∏
    RECT tabRect;
    GetClientRect(hTabControl, &tabRect);
    TabCtrl_AdjustRect(hTabControl, FALSE, &tabRect);

    // –¢–∞–±–ª–∏—Ü–∞ –æ–±—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    hResultsList = CreateListView(hTabControl, tabRect.left + 10, tabRect.top + 10,
        tabRect.right - tabRect.left - 20, tabRect.bottom - tabRect.top - 20, ID_RESULTS_LIST);
    AddListColumn(hResultsList, L"–ü–∞—Ä–∞–º–µ—Ç—Ä", 200, 0);
    AddListColumn(hResultsList, L"–ó–Ω–∞—á–µ–Ω–∏–µ", 150, 1);
    AddListColumn(hResultsList, L"–û–ø–∏—Å–∞–Ω–∏–µ", 700, 2);

    // –¢–∞–±–ª–∏—Ü–∞ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ - –ò–°–ü–†–ê–í–õ–ï–ù–´ –†–ê–ó–ú–ï–†–´ –°–¢–û–õ–ë–¶–û–í
    hClustersList = CreateListView(hTabControl, tabRect.left + 10, tabRect.top + 10,
        tabRect.right - tabRect.left - 20, tabRect.bottom - tabRect.top - 20, ID_CLUSTERS_LIST);
    AddListColumn(hClustersList, L"–ö–ª–∞—Å—Ç–µ—Ä", 80, 0);
    AddListColumn(hClustersList, L"–¢–æ—á–µ–∫", 80, 1);
    AddListColumn(hClustersList, L"–ü—Ä–æ—Ü–µ–Ω—Ç", 80, 2);
    AddListColumn(hClustersList, L"–¶–µ–Ω—Ç—Ä–æ–∏–¥", 350, 3);  // –£–º–µ–Ω—å—à–µ–Ω–æ —Å 500 –¥–æ 350
    AddListColumn(hClustersList, L"–°—Ä. —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ", 120, 4);
    AddListColumn(hClustersList, L"–ö–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç—å", 120, 5);
    AddListColumn(hClustersList, L"–ö–∞—á–µ—Å—Ç–≤–æ", 130, 6);

    // –¢–∞–±–ª–∏—Ü–∞ —Ç–æ—á–µ–∫ - –ò–°–ü–†–ê–í–õ–ï–ù–´ –†–ê–ó–ú–ï–†–´ –°–¢–û–õ–ë–¶–û–í –î–õ–Ø –ü–†–ê–í–ò–õ–¨–ù–û–ì–û –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø
    hPointsList = CreateListView(hTabControl, tabRect.left + 10, tabRect.top + 10,
        tabRect.right - tabRect.left - 20, tabRect.bottom - tabRect.top - 20, ID_POINTS_LIST);
    AddListColumn(hPointsList, L"–¢–æ—á–∫–∞", 80, 0);
    AddListColumn(hPointsList, L"–ö–ª–∞—Å—Ç–µ—Ä", 80, 1);
    AddListColumn(hPointsList, L"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã", 400, 2);  // –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–º–µ–Ω—å—à–µ–Ω–æ —Å 1200 –¥–æ 400
    AddListColumn(hPointsList, L"–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–æ–∏–¥–∞", 180, 3);
    AddListColumn(hPointsList, L"–°—Ç–∞—Ç—É—Å", 150, 4);

    // –¢–∞–±–ª–∏—Ü–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    hStatsList = CreateListView(hTabControl, tabRect.left + 10, tabRect.top + 10,
        tabRect.right - tabRect.left - 20, tabRect.bottom - tabRect.top - 20, ID_STATS_LIST);
    AddListColumn(hStatsList, L"–ú–µ—Ç—Ä–∏–∫–∞", 200, 0);
    AddListColumn(hStatsList, L"–ó–Ω–∞—á–µ–Ω–∏–µ", 150, 1);
    AddListColumn(hStatsList, L"–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è", 700, 2);

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —à—Ä–∏—Ñ—Ç—ã
    SendMessage(hResultsList, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hClustersList, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hPointsList, WM_SETFONT, (WPARAM)hFontText, TRUE);
    SendMessage(hStatsList, WM_SETFONT, (WPARAM)hFontText, TRUE);

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é –≤–∫–ª–∞–¥–∫—É
    ShowTabContent(0);
}

// –ò–°–ü–†–ê–í–õ–ï–ù–ê —Ñ—É–Ω–∫—Ü–∏—è ResizeInterface —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Ä–∞–∑–º–µ—Ä–æ–≤
void ResizeInterface(HWND hWnd, int width, int height)
{
    if (width < 1400) width = 1400;
    if (height < 900) height = 900;

    // –ò–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä TabControl
    if (hTabControl)
        SetWindowPos(hTabControl, NULL, 450, 200, width - 480, height - 240, SWP_NOZORDER);

    // –ò–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è —Å—Ç–∞—Ç—É—Å–∞
    if (hStatusText)
        SetWindowPos(hStatusText, NULL, 520, 120, width - 550, 60, SWP_NOZORDER);

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Ç–∞–±–ª–∏—Ü –≤–Ω—É—Ç—Ä–∏ –≤–∫–ª–∞–¥–æ–∫
    if (hTabControl) {
        RECT tabRect;
        GetClientRect(hTabControl, &tabRect);
        TabCtrl_AdjustRect(hTabControl, FALSE, &tabRect);

        int tableWidth = tabRect.right - tabRect.left - 20;
        int tableHeight = tabRect.bottom - tabRect.top - 20;

        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Ä–∞–∑–º–µ—Ä—ã –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ
        if (tableWidth > 0 && tableHeight > 0) {
            if (hResultsList)
                SetWindowPos(hResultsList, NULL, tabRect.left + 10, tabRect.top + 10,
                    tableWidth, tableHeight, SWP_NOZORDER);
            if (hClustersList)
                SetWindowPos(hClustersList, NULL, tabRect.left + 10, tabRect.top + 10,
                    tableWidth, tableHeight, SWP_NOZORDER);
            if (hPointsList)
                SetWindowPos(hPointsList, NULL, tabRect.left + 10, tabRect.top + 10,
                    tableWidth, tableHeight, SWP_NOZORDER);
            if (hStatsList)
                SetWindowPos(hStatsList, NULL, tabRect.left + 10, tabRect.top + 10,
                    tableWidth, tableHeight, SWP_NOZORDER);
        }
    }
}

void ShowTabContent(int tabIndex)
{
    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã
    ShowWindow(hResultsList, SW_HIDE);
    ShowWindow(hClustersList, SW_HIDE);
    ShowWindow(hPointsList, SW_HIDE);
    ShowWindow(hStatsList, SW_HIDE);

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω—É–∂–Ω—É—é —Ç–∞–±–ª–∏—Ü—É
    switch (tabIndex)
    {
    case 0: ShowWindow(hResultsList, SW_SHOW); break;
    case 1: ShowWindow(hClustersList, SW_SHOW); break;
    case 2: ShowWindow(hPointsList, SW_SHOW); break;
    case 3: ShowWindow(hStatsList, SW_SHOW); break;
    }
}

// –ò–°–ü–†–ê–í–õ–ï–ù–ê —Ñ—É–Ω–∫—Ü–∏—è CreateListView —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞–º–∏
HWND CreateListView(HWND parent, int x, int y, int w, int h, int id)
{
    HWND hList = CreateWindowW(WC_LISTVIEW, L"",
        WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT | LVS_SINGLESEL |
        LVS_SHOWSELALWAYS | WS_VSCROLL | WS_HSCROLL,  // –û–°–¢–ê–í–õ–ï–ù–´ –û–ë–ê –°–ö–†–û–õ–õ–ë–ê–†–ê
        x, y, w, h, parent, (HMENU)id, hInst, nullptr);

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    ListView_SetExtendedListViewStyle(hList,
        LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);

    return hList;
}

// –î–û–ë–ê–í–õ–ï–ù–ê –Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ —Å—Ç–æ–ª–±—Ü–æ–≤
void AutoResizeColumns(HWND hListView)
{
    int columnCount = Header_GetItemCount(ListView_GetHeader(hListView));

    for (int i = 0; i < columnCount; i++) {
        ListView_SetColumnWidth(hListView, i, LVSCW_AUTOSIZE_USEHEADER);

        // –ü–æ–ª—É—á–∞–µ–º —à–∏—Ä–∏–Ω—É –ø–æ—Å–ª–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
        int autoWidth = ListView_GetColumnWidth(hListView, i);

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É
        int minWidth = 80;
        if (autoWidth < minWidth) {
            ListView_SetColumnWidth(hListView, i, minWidth);
        }
    }
}

void AddListColumn(HWND hList, LPCWSTR text, int width, int index)
{
    LVCOLUMN lvc = { 0 };
    lvc.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.pszText = (LPWSTR)text;
    lvc.cx = width;
    lvc.iSubItem = index;
    ListView_InsertColumn(hList, index, &lvc);
}

void AddListItem(HWND hList, int item, int subitem, LPCWSTR text)
{
    LVITEM lvi = { 0 };
    lvi.mask = LVIF_TEXT;
    lvi.iItem = item;
    lvi.iSubItem = subitem;
    lvi.pszText = (LPWSTR)text;

    if (subitem == 0) {
        ListView_InsertItem(hList, &lvi);
    }
    else {
        ListView_SetItem(hList, &lvi);
    }
}

void ClearList(HWND hList)
{
    ListView_DeleteAllItems(hList);
}

void ShowWelcomeScreen()
{
    UpdateStatus(L"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ K-means!\r\n\r\n–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã:\r\n1. –ó–∞–≥—Ä—É–∑–∏—Ç–µ CSV —Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏\r\n2. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\r\n3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑");

    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É –æ–±—â–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    ClearList(hResultsList);
    AddListItem(hResultsList, 0, 0, L"–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã");
    AddListItem(hResultsList, 0, 1, L"–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ");
    AddListItem(hResultsList, 0, 2, L"–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –∑–∞–≥—Ä—É–∑–∫–µ –∏ –∞–Ω–∞–ª–∏–∑—É –¥–∞–Ω–Ω—ã—Ö");

    AddListItem(hResultsList, 1, 0, L"–ê–ª–≥–æ—Ä–∏—Ç–º");
    AddListItem(hResultsList, 1, 1, L"K-means++");
    AddListItem(hResultsList, 1, 2, L"–£–ª—É—á—à–µ–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤ –¥–ª—è –ª—É—á—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤");

    AddListItem(hResultsList, 2, 0, L"–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã");
    AddListItem(hResultsList, 2, 1, L"CSV, TXT");
    AddListItem(hResultsList, 2, 2, L"–§–∞–π–ª—ã —Å —á–∏—Å–ª–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–º–∏ –∑–∞–ø—è—Ç—ã–º–∏ –∏–ª–∏ —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π");

    ClearList(hClustersList);
    ClearList(hPointsList);
    ClearList(hStatsList);

    UpdateKRangeLabel();
}

void ShowDataLoadedInfo()
{
    std::wstringstream status;
    status << L"–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!\r\n\r\n";
    status << L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫: " << points.size() << L"\r\n";
    status << L"–†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å: " << (points.empty() ? 0 : points[0].coords.size()) << L"\r\n";
    status << L"–ì–æ—Ç–æ–≤ –∫ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏!";
    UpdateStatus(status.str());

    PopulateResultsTable();
    PopulatePointsTable();
    UpdateKRangeLabel();
}

void ShowClusteringResults()
{
    std::wstringstream status;
    status << L"–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\r\n\r\n";
    status << L"–í—ã–ø–æ–ª–Ω–µ–Ω–æ –∏—Ç–µ—Ä–∞—Ü–∏–π: " << currentIteration << L"/" << maxIterations << L"\r\n";
    status << L"–°—Ö–æ–¥–∏–º–æ—Å—Ç—å: " << (isConverged ? L"–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞" : L"–ù–µ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞") << L"\r\n";
    status << L"–û–±—â–∞—è –æ—à–∏–±–∫–∞ SSE: " << std::fixed << std::setprecision(4) << totalSSE;
    UpdateStatus(status.str());

    PopulateResultsTable();
    PopulateClustersTable();
    PopulatePointsTable();
    PopulateStatsTable();
}

void UpdateStatus(const std::wstring& message)
{
    SetWindowTextW(hStatusText, message.c_str());
}

void PopulateResultsTable()
{
    ClearList(hResultsList);

    if (clusters.empty()) {
        AddListItem(hResultsList, 0, 0, L"–°—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö");
        AddListItem(hResultsList, 0, 1, L"–ó–∞–≥—Ä—É–∂–µ–Ω—ã");
        AddListItem(hResultsList, 0, 2, L"–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞");

        std::wstring pointsStr = std::to_wstring(points.size());
        AddListItem(hResultsList, 1, 0, L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫");
        AddListItem(hResultsList, 1, 1, pointsStr.c_str());
        AddListItem(hResultsList, 1, 2, L"–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏");

        std::wstring dimsStr = std::to_wstring(points.empty() ? 0 : points[0].coords.size());
        AddListItem(hResultsList, 2, 0, L"–†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö");
        AddListItem(hResultsList, 2, 1, dimsStr.c_str());
        AddListItem(hResultsList, 2, 2, L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–º–µ—Ä–µ–Ω–∏–π (–ø—Ä–∏–∑–Ω–∞–∫–æ–≤) –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏");
    }
    else {
        AddListItem(hResultsList, 0, 0, L"–°—Ç–∞—Ç—É—Å –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏");
        AddListItem(hResultsList, 0, 1, L"–ó–∞–≤–µ—Ä—à–µ–Ω–∞");
        AddListItem(hResultsList, 0, 2, L"–ê–ª–≥–æ—Ä–∏—Ç–º K-means —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω");

        std::wstring iterStr = std::to_wstring(currentIteration) + L"/" + std::to_wstring(maxIterations);
        AddListItem(hResultsList, 1, 0, L"–ò—Ç–µ—Ä–∞—Ü–∏–∏");
        AddListItem(hResultsList, 1, 1, iterStr.c_str());
        AddListItem(hResultsList, 1, 2, L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º–∞");

        AddListItem(hResultsList, 2, 0, L"–°—Ö–æ–¥–∏–º–æ—Å—Ç—å");
        AddListItem(hResultsList, 2, 1, isConverged ? L"–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞" : L"–ù–µ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞");
        AddListItem(hResultsList, 2, 2, isConverged ? L"–ê–ª–≥–æ—Ä–∏—Ç–º —Å–æ—à–µ–ª—Å—è –∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–º—É —Ä–µ—à–µ–Ω–∏—é" : L"–¢—Ä–µ–±—É–µ—Ç—Å—è –±–æ–ª—å—à–µ –∏—Ç–µ—Ä–∞—Ü–∏–π");

        std::wstring kStr = std::to_wstring(k);
        AddListItem(hResultsList, 3, 0, L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤");
        AddListItem(hResultsList, 3, 1, kStr.c_str());
        AddListItem(hResultsList, 3, 2, L"–ó–∞–¥–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞");

        std::wstringstream sseStr;
        sseStr << std::fixed << std::setprecision(6) << totalSSE;
        AddListItem(hResultsList, 4, 0, L"–û–±—â–∞—è –æ—à–∏–±–∫–∞ (SSE)");
        AddListItem(hResultsList, 4, 1, sseStr.str().c_str());
        AddListItem(hResultsList, 4, 2, L"–°—É–º–º–∞ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –¥–æ —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤ (—á–µ–º –º–µ–Ω—å—à–µ, —Ç–µ–º –ª—É—á—à–µ)");
    }
}

void PopulateClustersTable()
{
    ClearList(hClustersList);

    for (int i = 0; i < k; i++) {
        std::wstring clusterNum = std::to_wstring(i + 1);
        std::wstring pointCount = std::to_wstring(clusters[i].pointCount);

        double percentage = (clusters[i].pointCount * 100.0) / points.size();
        std::wstringstream percentStr;
        percentStr << std::fixed << std::setprecision(1) << percentage << L"%";

        std::wstringstream centroidStr;
        centroidStr << L"(";
        for (size_t j = 0; j < clusters[i].centroid.size(); j++) {
            centroidStr << std::fixed << std::setprecision(3) << clusters[i].centroid[j];
            if (j < clusters[i].centroid.size() - 1) centroidStr << L", ";
        }
        centroidStr << L")";

        std::wstringstream avgDistStr;
        avgDistStr << std::fixed << std::setprecision(6) << clusters[i].avgDistance;

        std::wstringstream compactnessStr;
        compactnessStr << std::fixed << std::setprecision(1) << (clusters[i].compactness * 100) << L"%";

        std::wstring quality;
        if (clusters[i].compactness > 0.8) quality = L"–û—Ç–ª–∏—á–Ω–æ–µ";
        else if (clusters[i].compactness > 0.6) quality = L"–•–æ—Ä–æ—à–µ–µ";
        else if (clusters[i].compactness > 0.4) quality = L"–°—Ä–µ–¥–Ω–µ–µ";
        else quality = L"–ù–∏–∑–∫–æ–µ";

        AddListItem(hClustersList, i, 0, clusterNum.c_str());
        AddListItem(hClustersList, i, 1, pointCount.c_str());
        AddListItem(hClustersList, i, 2, percentStr.str().c_str());
        AddListItem(hClustersList, i, 3, centroidStr.str().c_str());
        AddListItem(hClustersList, i, 4, avgDistStr.str().c_str());
        AddListItem(hClustersList, i, 5, compactnessStr.str().c_str());
        AddListItem(hClustersList, i, 6, quality.c_str());
    }
}

void PopulatePointsTable()
{
    ClearList(hPointsList);

    for (size_t i = 0; i < points.size(); i++) {
        std::wstring pointNum = std::to_wstring(i + 1);

        std::wstring clusterStr;
        if (points[i].clusterLabel >= 0) {
            clusterStr = std::to_wstring(points[i].clusterLabel + 1);
        }
        else {
            clusterStr = L"–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω";
        }

        std::wstringstream coordsStr;
        coordsStr << L"(";
        for (size_t j = 0; j < points[i].coords.size(); j++) {
            coordsStr << std::fixed << std::setprecision(3) << points[i].coords[j];
            if (j < points[i].coords.size() - 1) coordsStr << L", ";
        }
        coordsStr << L")";

        std::wstring distanceStr = L"-";
        std::wstring statusStr = L"–û–∂–∏–¥–∞–µ—Ç –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏";

        if (points[i].clusterLabel >= 0 && points[i].clusterLabel < (int)clusters.size()) {
            double distance = CalculateEuclideanDistance(points[i].coords, clusters[points[i].clusterLabel].centroid);
            std::wstringstream distStr;
            distStr << std::fixed << std::setprecision(6) << distance;
            distanceStr = distStr.str();

            if (distance < clusters[points[i].clusterLabel].avgDistance * 0.8) {
                statusStr = L"–ë–ª–∏–∑–∫–æ –∫ —Ü–µ–Ω—Ç—Ä—É";
            }
            else if (distance > clusters[points[i].clusterLabel].avgDistance * 1.5) {
                statusStr = L"–ù–∞ –ø–µ—Ä–∏—Ñ–µ—Ä–∏–∏";
            }
            else {
                statusStr = L"–¢–∏–ø–∏—á–Ω–∞—è —Ç–æ—á–∫–∞";
            }
        }

        AddListItem(hPointsList, static_cast<int>(i), 0, pointNum.c_str());
        AddListItem(hPointsList, static_cast<int>(i), 1, clusterStr.c_str());
        AddListItem(hPointsList, static_cast<int>(i), 2, coordsStr.str().c_str());
        AddListItem(hPointsList, static_cast<int>(i), 3, distanceStr.c_str());
        AddListItem(hPointsList, static_cast<int>(i), 4, statusStr.c_str());
    }

    // –î–û–ë–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –¥–æ –∫–æ–Ω—Ü–∞
    int emptyRowsCount = 20; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ –¥–ª—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
    for (int emptyRow = 0; emptyRow < emptyRowsCount; emptyRow++) {
        int rowIndex = static_cast<int>(points.size()) + emptyRow;
        AddListItem(hPointsList, rowIndex, 0, L"");
        AddListItem(hPointsList, rowIndex, 1, L"");
        AddListItem(hPointsList, rowIndex, 2, L"");
        AddListItem(hPointsList, rowIndex, 3, L"");
        AddListItem(hPointsList, rowIndex, 4, L"");
    }

    // –î–û–ë–ê–í–õ–ï–ù–û: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
    // AutoResizeColumns(hPointsList);  // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä
}

void PopulateStatsTable()
{
    ClearList(hStatsList);

    int row = 0;

    std::wstringstream totalPointsStr;
    totalPointsStr << points.size();
    AddListItem(hStatsList, row, 0, L"–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫");
    AddListItem(hStatsList, row, 1, totalPointsStr.str().c_str());
    AddListItem(hStatsList, row++, 2, L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö, —É—á–∞—Å—Ç–≤—É—é—â–∏—Ö –≤ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏");

    double avgSSE = totalSSE / points.size();
    std::wstringstream avgSSEStr;
    avgSSEStr << std::fixed << std::setprecision(6) << avgSSE;
    AddListItem(hStatsList, row, 0, L"–°—Ä–µ–¥–Ω—è—è –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞");
    AddListItem(hStatsList, row, 1, avgSSEStr.str().c_str());

    std::wstring sseInterpretation;
    if (avgSSE < 1.0) sseInterpretation = L"–û—Ç–ª–∏—á–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏";
    else if (avgSSE < 5.0) sseInterpretation = L"–•–æ—Ä–æ—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏";
    else if (avgSSE < 20.0) sseInterpretation = L"–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ";
    else sseInterpretation = L"–ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ, —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤";

    AddListItem(hStatsList, row++, 2, sseInterpretation.c_str());

    double avgClusterSize = (double)points.size() / k;
    bool balanced = true;
    for (const auto& cluster : clusters) {
        if (cluster.pointCount < avgClusterSize * 0.3 || cluster.pointCount > avgClusterSize * 2.0) {
            balanced = false;
            break;
        }
    }

    AddListItem(hStatsList, row, 0, L"–ë–∞–ª–∞–Ω—Å –∫–ª–∞—Å—Ç–µ—Ä–æ–≤");
    AddListItem(hStatsList, row, 1, balanced ? L"–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω—ã" : L"–ù–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω—ã");
    AddListItem(hStatsList, row++, 2, balanced ? L"–ö–ª–∞—Å—Ç–µ—Ä—ã –∏–º–µ—é—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ä–∞–≤–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã" : L"–†–∞–∑–º–µ—Ä—ã –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ —Å–∏–ª—å–Ω–æ —Ä–∞–∑–ª–∏—á–∞—é—Ç—Å—è");

    AddListItem(hStatsList, row, 0, L"–°—Ö–æ–¥–∏–º–æ—Å—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–∞");
    AddListItem(hStatsList, row, 1, isConverged ? L"–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞" : L"–ù–µ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞");
    AddListItem(hStatsList, row++, 2, isConverged ? L"–ê–ª–≥–æ—Ä–∏—Ç–º –Ω–∞—à–µ–ª —Å—Ç–∞–±–∏–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ" : L"–£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π");
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_SIZE:
        ResizeInterface(hWnd, LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        if (pnmh->hwndFrom == hTabControl && pnmh->code == TCN_SELCHANGE)
        {
            int selectedTab = TabCtrl_GetCurSel(hTabControl);
            ShowTabContent(selectedTab);
        }
        break;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_LOAD_BUTTON:
            LoadDataFile();
            break;
        case ID_CLEAR_BUTTON:
            ClearAllData();
            break;
        case ID_CALC_BUTTON:
            RunClusteringAnalysis();
            break;
        case ID_EXPORT_BUTTON:
            ExportDetailedResults();
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π K-means –∞–ª–≥–æ—Ä–∏—Ç–º–∞

// –ò–°–ü–†–ê–í–õ–ï–ù–ê —Ñ—É–Ω–∫—Ü–∏—è LoadDataFile —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π
void LoadDataFile()
{
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetActiveWindow();
    ofn.lpstrFilter = L"CSV Files (*.csv)\0*.csv\0Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

    if (GetOpenFileName(&ofn))
    {
        ClearAllData();
        SendMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
        SendMessage(hProgressBar, PBM_SETPOS, 10, 0);
        UpdateStatus(L"–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞...");

        std::wifstream file(szFile);
        std::wstring line;

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        wchar_t delimiter = L',';
        if (std::getline(file, line)) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–æ–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
            if (line.find(L';') != std::wstring::npos) {
                delimiter = L';';
            }
            else if (line.find(L',') != std::wstring::npos) {
                delimiter = L',';
            }
            else if (line.find(L'\t') != std::wstring::npos) {
                delimiter = L'\t';
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
            bool isHeader = false;
            std::wstringstream ss(line);
            std::wstring token;
            while (std::getline(ss, token, delimiter)) {
                // –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã
                token.erase(std::remove_if(token.begin(), token.end(), ::iswspace), token.end());
                if (!token.empty()) {
                    try {
                        std::stod(token);
                    }
                    catch (...) {
                        isHeader = true;
                        break;
                    }
                }
            }

            // –ï—Å–ª–∏ –Ω–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–∞—á–∞–ª—É —Ñ–∞–π–ª–∞
            if (!isHeader) {
                file.seekg(0);
            }
        }

        // –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        while (std::getline(file, line))
        {
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            if (line.empty()) continue;

            std::wstringstream ss(line);
            std::wstring token;
            Point p;
            p.originalIndex = static_cast<int>(points.size());

            // –ü–∞—Ä—Å–∏–º –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–º
            while (std::getline(ss, token, delimiter))
            {
                try {
                    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –ø—Ä–æ–±–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    token.erase(std::remove_if(token.begin(), token.end(), ::iswspace), token.end());

                    if (!token.empty()) {
                        // –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É –¥–ª—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö —á–∏—Å–µ–ª (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
                        std::replace(token.begin(), token.end(), L',', L'.');

                        double value = std::stod(token);
                        if (std::isfinite(value)) {
                            p.coords.push_back(value);
                        }
                    }
                }
                catch (const std::exception&) {
                    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Å—Ç—Ä–æ–∫–∏
                    continue;
                }
            }

            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É –Ω–µ—ë –µ—Å—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
            if (!p.coords.empty()) {
                points.push_back(p);
            }
        }

        file.close();
        SendMessage(hProgressBar, PBM_SETPOS, 100, 0);

        if (!points.empty()) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Ç–æ—á–∫–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–º–µ—Ä–µ–Ω–∏–π
            size_t expectedDimensions = points[0].coords.size();
            bool dimensionsConsistent = true;

            for (const auto& point : points) {
                if (point.coords.size() != expectedDimensions) {
                    dimensionsConsistent = false;
                    break;
                }
            }

            if (dimensionsConsistent) {
                std::wstringstream successMsg;
                successMsg << L"–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!\r\n\r\n";
                successMsg << L"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫: " << points.size() << L"\r\n";
                successMsg << L"–†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å: " << expectedDimensions << L"\r\n";
                successMsg << L"–†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å: " << (delimiter == L';' ? L"—Ç–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π (;)" :
                    delimiter == L',' ? L"–∑–∞–ø—è—Ç–∞—è (,)" : L"—Ç–∞–±—É–ª—è—Ü–∏—è") << L"\r\n";
                successMsg << L"–ì–æ—Ç–æ–≤ –∫ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏!";
                UpdateStatus(successMsg.str());

                ShowDataLoadedInfo();
            }
            else {
                UpdateStatus(L"–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Å—Ç—Ä–æ–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å—Ç–æ–ª–±—Ü–æ–≤.\r\n–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.");
                ShowDataLoadedInfo();
            }
        }
        else {
            std::wstringstream errorMsg;
            errorMsg << L"–û—à–∏–±–∫–∞: –í —Ñ–∞–π–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —á–∏—Å–ª–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ.\r\n\r\n";
            errorMsg << L"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞:\r\n";
            errorMsg << L"- –ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å: " << (delimiter == L';' ? L";" : delimiter == L',' ? L"," : L"—Ç–∞–±—É–ª—è—Ü–∏—è") << L"\r\n";
            errorMsg << L"- –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ\r\n";
            errorMsg << L"- –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥–∏—Ä–æ–≤–∫—É —Ñ–∞–π–ª–∞";
            UpdateStatus(errorMsg.str());
            SendMessage(hProgressBar, PBM_SETPOS, 0, 0);
        }
    }
}

void RunClusteringAnalysis()
{
    if (points.empty()) {
        UpdateStatus(L"–û—à–∏–±–∫–∞: –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ!");
        return;
    }

    wchar_t buffer[32];
    GetWindowTextW(hKInput, buffer, 32);
    k = _wtoi(buffer);

    GetWindowTextW(hThresholdInput, buffer, 32);
    convergenceThreshold = _wtof(buffer);

    GetWindowTextW(hMaxIterInput, buffer, 32);
    maxIterations = _wtoi(buffer);

    if (k < 1 || k > static_cast<int>(points.size())) {
        std::wstringstream errorMsg;
        errorMsg << L"–û—à–∏–±–∫–∞: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ " << points.size() << L" (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö).";
        UpdateStatus(errorMsg.str());
        return;
    }

    if (convergenceThreshold <= 0 || convergenceThreshold >= 1) {
        UpdateStatus(L"–û—à–∏–±–∫–∞: –ü–æ—Ä–æ–≥ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–∂–¥—É 0 –∏ 1.");
        return;
    }

    startTime = std::chrono::steady_clock::now();
    SendMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, maxIterations));
    UpdateStatus(L"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤...");

    InitializeCentroidsKMeansPlusPlus();
    currentIteration = 0;
    isConverged = false;

    std::vector<std::vector<double>> prevCentroids;

    while (currentIteration < maxIterations && !isConverged)
    {
        prevCentroids.clear();
        for (const auto& cluster : clusters) {
            prevCentroids.push_back(cluster.centroid);
        }

        AssignPointsToClusters();
        UpdateClusterCentroids();

        isConverged = true;
        for (int i = 0; i < k; i++) {
            if (CalculateEuclideanDistance(clusters[i].centroid, prevCentroids[i]) > convergenceThreshold) {
                isConverged = false;
                break;
            }
        }

        currentIteration++;
        SendMessage(hProgressBar, PBM_SETPOS, currentIteration, 0);

        if (currentIteration % 5 == 0) {
            std::wstringstream status;
            status << L"–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏... –ò—Ç–µ—Ä–∞—Ü–∏—è " << currentIteration << L"/" << maxIterations;
            UpdateStatus(status.str());
        }
    }

    CalculateDetailedStatistics();
    ShowClusteringResults();
}

void InitializeCentroidsKMeansPlusPlus()
{
    clusters.clear();
    clusters.resize(k);

    std::uniform_int_distribution<size_t> dist(0, points.size() - 1);
    clusters[0].centroid = points[dist(rng)].coords;

    for (int i = 1; i < k; i++) {
        std::vector<double> distances(points.size());
        double totalDist = 0.0;

        for (size_t j = 0; j < points.size(); j++) {
            double minDist = std::numeric_limits<double>::max();
            for (int c = 0; c < i; c++) {
                double d = CalculateEuclideanDistance(points[j].coords, clusters[c].centroid);
                minDist = std::min(minDist, d);
            }
            distances[j] = minDist * minDist;
            totalDist += distances[j];
        }

        std::uniform_real_distribution<double> realDist(0.0, totalDist);
        double target = realDist(rng);
        double cumulative = 0.0;

        for (size_t j = 0; j < points.size(); j++) {
            cumulative += distances[j];
            if (cumulative >= target) {
                clusters[i].centroid = points[j].coords;
                break;
            }
        }
    }
}

double CalculateEuclideanDistance(const std::vector<double>& a, const std::vector<double>& b)
{
    if (a.size() != b.size()) return std::numeric_limits<double>::max();

    double sum = 0.0;
    for (size_t i = 0; i < a.size(); i++) {
        double diff = a[i] - b[i];
        sum += diff * diff;
    }
    return std::sqrt(sum);
}

void AssignPointsToClusters()
{
    for (auto& cluster : clusters) {
        cluster.pointCount = 0;
    }

    for (auto& point : points) {
        double minDist = std::numeric_limits<double>::max();
        int bestCluster = 0;

        for (int i = 0; i < k; i++) {
            double dist = CalculateEuclideanDistance(point.coords, clusters[i].centroid);
            if (dist < minDist) {
                minDist = dist;
                bestCluster = i;
            }
        }

        point.clusterLabel = bestCluster;
        clusters[bestCluster].pointCount++;
    }
}

void UpdateClusterCentroids()
{
    for (int i = 0; i < k; i++) {
        if (clusters[i].pointCount == 0) continue;

        std::vector<double> newCentroid(clusters[i].centroid.size(), 0.0);

        for (const auto& point : points) {
            if (point.clusterLabel == i) {
                for (size_t j = 0; j < point.coords.size(); j++) {
                    newCentroid[j] += point.coords[j];
                }
            }
        }

        for (size_t j = 0; j < newCentroid.size(); j++) {
            newCentroid[j] /= clusters[i].pointCount;
        }

        clusters[i].centroid = newCentroid;
    }
}

void CalculateDetailedStatistics()
{
    totalSSE = 0.0;

    for (int i = 0; i < k; i++) {
        if (clusters[i].pointCount == 0) {
            clusters[i].avgDistance = 0.0;
            clusters[i].minDistance = 0.0;
            clusters[i].maxDistance = 0.0;
            clusters[i].variance = 0.0;
            clusters[i].compactness = 0.0;
            continue;
        }

        double totalDist = 0.0;
        clusters[i].minDistance = std::numeric_limits<double>::max();
        clusters[i].maxDistance = 0.0;
        std::vector<double> distances;

        for (const auto& point : points) {
            if (point.clusterLabel == i) {
                double dist = CalculateEuclideanDistance(point.coords, clusters[i].centroid);
                totalDist += dist;
                distances.push_back(dist);
                clusters[i].minDistance = std::min(clusters[i].minDistance, dist);
                clusters[i].maxDistance = std::max(clusters[i].maxDistance, dist);
                totalSSE += dist * dist;
            }
        }

        clusters[i].avgDistance = totalDist / clusters[i].pointCount;

        double variance = 0.0;
        for (double dist : distances) {
            variance += (dist - clusters[i].avgDistance) * (dist - clusters[i].avgDistance);
        }
        clusters[i].variance = variance / distances.size();

        if (clusters[i].maxDistance > 0) {
            clusters[i].compactness = 1.0 - (clusters[i].avgDistance / clusters[i].maxDistance);
        }
        else {
            clusters[i].compactness = 1.0;
        }
    }
}

bool ExportDetailedResults()
{
    if (points.empty() || clusters.empty()) {
        UpdateStatus(L"–û—à–∏–±–∫–∞: –ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞. –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—é.");
        return false;
    }

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetActiveWindow();
    ofn.lpstrFilter = L"Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
    ofn.lpstrFile = szSaveFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrDefExt = L"txt";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    wcscpy_s(szSaveFile, L"kmeans_results.txt");

    if (GetSaveFileName(&ofn))
    {
        std::ofstream file(szSaveFile);
        if (!file.is_open()) {
            UpdateStatus(L"–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.");
            return false;
        }

        file << "=== ENHANCED K-MEANS CLUSTERING RESULTS - PERFECT EDITION ===\n\n";

        file << "Parameters:\n";
        file << "  Number of clusters (k): " << k << "\n";
        file << "  Convergence threshold: " << std::fixed << std::setprecision(2) << convergenceThreshold << "\n";
        file << "  Max iterations: " << maxIterations << "\n";
        file << "  Actual iterations: " << currentIteration << "\n\n";

        file << "Quality metrics:\n";
        file << "  SSE (Sum of Squared Errors): " << std::fixed << std::setprecision(6) << totalSSE << "\n\n";

        file << "Cluster assignments:\n";
        for (size_t i = 0; i < points.size(); i++) {
            file << "Point " << (i + 1) << ": Cluster " << (points[i].clusterLabel + 1) << " (";
            for (size_t j = 0; j < points[i].coords.size(); j++) {
                file << std::fixed << std::setprecision(3) << points[i].coords[j];
                if (j < points[i].coords.size() - 1) file << ", ";
            }
            file << ")\n";
        }

        file << "\nCluster centroids and statistics:\n";
        for (int i = 0; i < k; i++) {
            file << "Cluster " << (i + 1) << ":\n";
            file << "  Points: " << clusters[i].pointCount << "\n";
            file << "  Centroid: (";
            for (size_t j = 0; j < clusters[i].centroid.size(); j++) {
                file << std::fixed << std::setprecision(6) << clusters[i].centroid[j];
                if (j < clusters[i].centroid.size() - 1) file << ", ";
            }
            file << ")\n";
            file << "  Average intra-cluster distance: " << std::fixed << std::setprecision(6) << clusters[i].avgDistance << "\n\n";
        }

        file.close();

        UpdateStatus(L"–û—Ç—á–µ—Ç —É—Å–ø–µ—à–Ω–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω!\r\n\r\n–§–∞–π–ª: " + std::wstring(szSaveFile));
        return true;
    }

    return false;
}

void ClearAllData()
{
    points.clear();
    clusters.clear();
    currentIteration = 0;
    isConverged = false;
    totalSSE = 0.0;
    SendMessage(hProgressBar, PBM_SETPOS, 0, 0);
    ShowWelcomeScreen();
}
